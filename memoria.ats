.pagewidth 80
.pageheight 63
.tabstop 4
.indent on
.header "MEMORIA RC" "NanoFiles" pagenumext

.margin 1 0 1 0
.align justify

.title MEMORIA REDES DE COMPUTADORES - Nanofiles
.author Ángel Ruiz Fernandez & Marco Aurelio Santos Gómez
.date 2° de Informatica - Grupo 2.2 - Profesor Eduardo Salvador Iniesta Soto

.titlepage

.tableofcontents

.chapter Introducción

El presente documento tiene el objetivo de describir el desarrollo del proyecto de prácticas Nano-Files de la asignatura Redes de Comunicaciones. Cursada en el segundo año del Grado Ingeniería en Informática de la Universidad de Murcia.

El proyecto consiste en el desarrollo de un sistema de compartición y transferencia de archivos en red usando una metodología Peer-to-Peer. A continuación se especifican las decisiones de diseño tomadas. 

.chapter Protocolos

El sistema está conformado por un conjunto de peers que pueden compartir archivos entre sí usando el protocolo TCP. En adición, los peers mantienen contacto con un servidor directorio que contiene información general del servicio Nano-files. Dice qué archivos están disponibles y qué peers sirven dichos archivos. La comunicación con dicho directorio se efectúa mediante protocolo UDP.

En esta sección se especifican los formatos de los mensajes usados en la comunicación Peer-Peer y Peer-Directorio. Así como el comportamiento de estos en cada momento del intercambio de información.

.align left
.itemize Notación
.item asdf: static data
.item < >: mandatory field
.item [ ]: optional field
.item [...]: last object N times
.item All sizes are in bytes


.section Directorio

Codificados en texto plano UTF-8 siguiendo el formato codigo:valor sin
espacios en blanco y sobre protocolo UDP.

.subsection Mensajes de cliente

.subsubsection Ping request

Prueba la comunicación con el directorio y la compatibilidad del protocolo.

.align left
.itemize
.item Operación: `ping`
.item Campos: Identificador de protocolo.
.item Respuesta: ping reply

.fig
operation: ping
protocol: <protocol id>
.!fig

.subsubsection Filelist request

Solicita información de los archivos conocidos por el directorio.

.align left
.itemize
.item Operación: `filelist`
.item Campos: ninguno.
.item Respuesta: filelist reply

.fig
operation: filelist
.!fig

.pagebreak

.subsubsection Publish request

Informa al directorio de la lista de archivos disponibles para descargar desde
este cliente.


.align left
.itemize
.item Operación: `publish`
.item Campos: (ver más abajo), la lista puede estar vacía.
.item Respuesta: publish response

.fig
operation: publish
[port: <port>]
file: <hash1>; <filename1>; <size1>
file: <hash2>; <filename2>; <size2>
[...]
.!fig

.subsection Mensajes del directorio

.subsubsection Ping reply

Respuesta de ping informando la compatibilidad del protocolo.

.align left
.itemize
.item Operación: `pingok`
.item Campos: ninguno.
.item Responde a: ping request

.fig
operation: pingok
.!fig

.subsubsection Ping bad reply

Notifica al cliente de que usa el protocolo incorrecto.

.align left
.itemize
.item Operación: `pingbad`
.item Campos: ninguno.
.item Respuesta a: ping request

.fig
operation: pingbad
.!fig

.subsubsection Filelist reply

Devuelve una lista con información de todos los ficheros conocidos por el
directorio (nombre, firma hash, tamaño y peers)

.align left
.itemize
.item Operación: `filelistres`
.item Campos: (ver más abajo), la lista puede estar vacía.
.item Respuesta a: filelist request

.fig
operation: filelistres
file: <hash1>; <filename1>; <size1>; <server1a>, <server1b> [...]
file: <hash2>; <filename2>; <size2>; <server2a>  <server2b> [...]
[...]
.!fig

.pagebreak

.subsubsection Publish reply

Confirmación del mensaje publish request.

.align left
.itemize
.item Operación: `publishack`
.item Campos: ninguno.
.item Respuesta a: publish request

.fig
operation: publishack
.!fig

.section Peer-to-Peer

Mensajes con formato binarios representados en little-endian sobre protocolo
TCP.

Todos los mensajes comienzan con un código de operación.

.subsection Mensajes de cliente

.subsubsection File request

Consulta la disponibilidad de un archivo para ser descargado.

.align left
.itemize
.item Código: 0x01
.item Campos:
.item - Hash[20]: firma hash del fichero.
.item Respuestas: accepted o file not found error

.fig
0        1        3        4        5        byte
+--------+
| opcode |
+-------------------------------------------+
| hash                                      |
|                                           |
|                                           |
|                                           |
+-------------------------------------------+
.!fig

.subsubsection Chunk request

Solicita al servidor el envío de un archivo.

.align left
.itemize
.item Código: 0x02
.item Campos:
.item - Offset[8]: byte de inicio del chunk.
.item - Size[4]: tamaño del chunk.
.item Respuestas: chunk o bad chunk request error

.fig
0        1       2       3       4       5       6       7       8         byte
+--------+----------------------------------------------------------------+
| opcode | offset                                                         |
+--------+----------------------+-----------------------------------------+
| size                          |
+-------------------------------+
.!fig


.subsubsection Stop download

Termina la descarga actual de un fichero.

.align left
.itemize
.item Código: 0x03
.item Campos: ninguno.
.item Respuestas: ninguna.

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsection Mensajes de servidor

.subsubsection Accepted

Informa de la disponibilidad de un fichero para ser descargado vía chunk requests.

.align left
.itemize
.item Código: 0x11
.item Campos: ninguno.
.item Respuesta a: file request

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsubsection Bad file request error

Fichero no disponible o no encontrado.

.align left
.itemize
.item Código: 0x12
.item Campos: ninguno.
.item Respuesta a: file request

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsubsection Chunk

Chunk de datos del fichero.

.align left
.itemize
.item Código: 0x13
.item Campos:
.item - size[4]: tamaño del chunk.
.item - data[size]: datos.
.item Respuesta a: chunk request

.fig
0        1       2       3       4       byte
+--------+------------------------------+
| opcode | size                         |
+--------+------------------------------+
| data ...
|
.!fig

.pagebreak

.subsubsection Bad chunk request error

Fichero no disponible o no encontrado.

.align left
.itemize
.item Código: 0x14
.item Campos: ninguno.
.item Respuesta a: chunk request
.align justify

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.chapter Mejoras

.chapter Capturas de pantalla de Wireshark

.chapter Conclusiones

.chapter Valoracion personal

.section Por qué el proyecto base de Nanofiles es malo: Un analisis

.subsection Elección del lenguaje

Java era un lenguaje ampliamente usado para escribir software nuevo... hace 15 años. Ahora se considera como mala opción, como deuda tecnica (por razones fuera del alcance de este documento) no se escribe nuevo software en el, solo se mantiene el antiguo porque es mas barato que reescribirlo.

Especificamente, Java es una opción terrible para este caso porque es un obstaculo para el objetivo del proyecto: aprender a escribir aplicaciones con sockets.

Java, siendo OOP puro, está sujeto a limitaciones que le impiden representar fielmente realmente como funcionan las cosas. La API tiene una serie de clases para representar datagramas UDP por ejemplo: los datagramas existen, pero la clase DatagramPacket es algo muy abstracto que en ningún momento representa el paquete real, sino juntar datos en una unidad porque sí. Java no sabe lo que es un datagrama realmente.

Que queremos enviar un cacho de datos a varias direcciones: tenemos que construir un DatagramPacket para cada vez, con los mismos datos, pero con una dirección de destino distinta. Java está lleno de estas construcciones, copias copias y copias y destrucciones completamente innecesarias.

Cada día nos alejamos mas de C: La API de sockets de Java está demasiado alejada de la verdad: la API de sockets POSIX. Esa que todos los sitemas operativos reales implementan de una forma u otra desde BSD 4.2 (incluso Windows), que es lo que la JVM realmente usa por debajo para hablar con la red.

Esta API POSIX, tenemos unos datos, y los enviamos a una direccion, en una sola llamada, y sin ningún tipo de construcción o copia de nada. Es el kernel el que coje el búfer de memoria, construye el paquete UDP, lo encapsula en un frame Ethernet y se lo pasa al driver de la tarjeta de red (generalmente).

.itemize
.item Java no esta diseñado para trabajar con datos binarios facilmente, teniendo que serializar y deserializar todo, y ni si quiera soporta tipos enteros sin signo explicitamente.
.item Aparentemente no hay forma de coger un trozo de un archivo y mandarlo por un socket sin copiar el bufer, lenguaje inutilizable, como se permite esto en 2025?
.item Java es muy inflexible en cuanto a operaciones no bloqueantes. POSIX tiene la syscall poll() para monitorear una lista de sockets en un solo thread, y Java tiene algo parecido pero crucialmente, en C puedes responder con llamadas bloqueantes sabiendo que no se van a bloquear, mientras que en Java solo puedes usar cosas no bloqueantes sobre un canal con select, lo cual es pedantico y molesto.

.section Problemas con el código

.subsection General

.align left
.itemize
.item Legibilidad horrible
.item Nombres confusos, ambiguos
.item Inconsistencias de patrones
.item Innecesariamente complicado
.item Verbosidad (mas culpa de Java supongo)
.item Exceso de comentarios, y además confusos
.item Capa sobre capa sobre capa de abstracciones: paso de datos entre clases que no hacen nada innecesariamente
.item Enumeraciones, arrays, estructuras innecesarias, como los comandos.
.align justify

.subsection Especifico

Nos dan el proyecto para Eclipse, usando el build system de eclipse. Con lo cual nos obligan a usar Eclipse. Los IDEs son un obstaculo para el aprendizaje. Tienen una cantidad de ruido visual increibles, son enormemente complicados de usar y suelen tener bugs y molestias. La alternativa es "convertirlo a gradle" y usar gradle que es otro build system terrible y innecesariamente complejo.

.itemize Ejemplo de TODO ambiguo: En cual se crea el hilo?
.item NFControllerP2P: "Arrancar servidor en segundo plano creando un nuevo hilo"
.item NFServer: "Añadir métodos a esta clase para: 1) Arrancar el servidor en un hilo nuevo que se ejecutará en segundo plano" La verdadera respuesta es que hay que fijarse que NFServer implementa Runnable, con lo cual es esta clase la que hay que pasar a un Thread, y run() el metodo que ejecuta el Thread, siendo este declarado efectivamente en NFControllerP2P.

.pagebreak

.itemize Ejemplo de TODO confuso e incongruente:
.item NFServer implements Runnable: "Añadir métodos a esta clase para: [...] 2) Detener el servidor (stopserver)" Como vas a parar el servidor dentro del mismo thread, si el thread está bloqueado en accept()? Si no se usan sockets no bloqueantes (no los hemos visto) la unica forma de detener el thread es terminandolo a la fuerza desde el thread Main.

.itemize Ejemplo de TODO directamente incorrecto:
.item NFServer.serveFilesToClient: "Los métodos lookupHashSubstring y lookupFilenameSubstring de la clase FileInfo" lookupHashSubstring no existe en ningún sitio. Además, estas utilidades deberían estar en la base de datos FileDatabase, literalmente son queries a la base de datos. Sin embargo, lookupFilePath sí que está en la FileDatabase, por qué? Es como si se hubieran puesto los metodos de forma aparentemente aleatoria por el codigo. Nota: esta función tampoco no sirve un proposito porque en el servidor se necesita el resto de campos del objeto FileInfo, no solo su path. Debería de haber un solo metodo para buscar en la db por hash o por nombre y devolver el FileInfo, solo que por alguna razón divinamente desconocida, a FileInfo le falta el getter del path. (Nota: solo tiene sentido guardar el path entero en FileInfo, ya que el nombre es parte del path y por tanto redundante)


.itemize FileDatabase es AdHoc, solo sirve como base de datos del cliente:
.item escanea un directorio
.item no puede guardar peers para usarse en NFDirectoryServer

DirMessage intenta representar todos los tipos de mensajes, haciendo la implementación terrible: encima de que estamos en un lenguaje OOP esto deberia ser resuelto por herencia para cada tipo de mensaje

NFDirectoryServer termina inmediatamente al recibir un mensaje mal formado, esto es una vulnerabilidad de Denial of Service

NanoFiles (cliente) termina inmediatamente en cuanto un comando falla. Cuando haces un ping y el directorio no responde, termina, en vez de dejarte volver a intentar

NFController.processCommand()[COM_DOWNLOAD]: A dos metodos aislados se le pasa la misma información inutil (una substring del nombre del archivo). Sin modificar estos, los dos metodos necesitan el hash del archivo -> tendrian que hacer la misma request al directorio para ver a que hash se corresponde (información util) para poder preguntar por A. los servidores y B. a los peers, los chunks del archivo. Diseño fundamentalmente defectuoso. Lo primero que se debería hacer es obtener la información util, el hash, que es con lo que se debe trabajar.


