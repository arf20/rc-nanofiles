.pagewidth 80
.pageheight 63
.tabstop 4
.indent on
.header "MEMORIA RC" "NanoFiles" pagenumext

.margin 1 0 1 0
.align justify

.title MEMORIA REDES DE COMPUTADORES - Nanofiles
.author Ángel Ruiz Fernandez & Marco Aurelio Santos Gómez
.date 2° de Informatica - Grupo 2.2 - Profesor Eduardo Salvador Iniesta Soto

.titlepage

.tableofcontents

.chapter Introducción

El presente documento tiene el objetivo de describir el desarrollo del proyecto de prácticas Nano-Files de la asignatura Redes de Comunicaciones. Cursada en el segundo año del Grado Ingeniería en Informática de la Universidad de Murcia.

El proyecto consiste en el desarrollo de un sistema de compartición y transferencia de archivos en red usando una metodología Peer-to-Peer. A continuación se especifican las decisiones de diseño tomadas. 

.chapter Protocolos

El sistema está conformado por un conjunto de peers que pueden compartir archivos entre sí usando el protocolo TCP. En adición, los peers mantienen contacto con un servidor directorio que contiene información general del servicio Nano-files. Dice qué archivos están disponibles y qué peers sirven dichos archivos. La comunicación con dicho directorio se efectúa mediante protocolo UDP.

En esta sección se especifican los formatos de los mensajes usados en la comunicación Peer-Peer y Peer-Directorio. Así como el comportamiento de estos en cada momento del intercambio de información.

.align left

.itemize Notación
.item asdf: static data
.item < >: mandatory field
.item [ ]: optional field
.item [...]: last object N times
.item All sizes are in bytes


.section Directorio

Codificados en texto plano UTF-8 siguiendo el formato codigo:valor sin
espacios en blanco y sobre protocolo UDP.

.subsection Mensajes de cliente

.subsubsection Ping request

Prueba la comunicación con el directorio y la compatibilidad del protocolo.

.itemize
.item Operación: `ping`
.item Campos: Identificador de protocolo.
.item Respuesta: ping reply

.fig
operation: ping
protocol: <protocol id>
.!fig

.subsubsection Filelist request

Solicita información de los archivos conocidos por el directorio.

.itemize
.item Operación: `filelist`
.item Campos: ninguno.
.item Respuesta: filelist reply

.fig
operation: filelist
.!fig

.pagebreak

.subsubsection Publish request

Informa al directorio de la lista de archivos disponibles para descargar desde
este cliente.


.itemize
.item Operación: `publish`
.item Campos: (ver más abajo), la lista puede estar vacía.
.item Respuesta: publish response

.fig
operation: publish
[port: <port>]
file: <hash1>; <filename1>; <size1>
file: <hash2>; <filename2>; <size2>
[...]
.!fig

.subsection Mensajes del directorio

.subsubsection Ping reply

Respuesta de ping informando la compatibilidad del protocolo.

.itemize
.item Operación: `pingok`
.item Campos: ninguno.
.item Responde a: ping request

.fig
operation: pingok
.!fig

.subsubsection Ping bad reply

Notifica al cliente de que usa el protocolo incorrecto.

.itemize
.item Operación: `pingbad`
.item Campos: ninguno.
.item Respuesta a: ping request

.fig
operation: pingbad
.!fig

.subsubsection Filelist reply

Devuelve una lista con información de todos los ficheros conocidos por el
directorio (nombre, firma hash, tamaño y peers)

.itemize
.item Operación: `filelistres`
.item Campos: (ver más abajo), la lista puede estar vacía.
.item Respuesta a: filelist request

.fig
operation: filelistres
file: <hash1>; <filename1>; <size1>; <server1a>, <server1b> [...]
file: <hash2>; <filename2>; <size2>; <server2a>  <server2b> [...]
[...]
.!fig

.pagebreak

.subsubsection Publish reply

Confirmación del mensaje publish request.

.itemize
.item Operación: `publishack`
.item Campos: ninguno.
.item Respuesta a: publish request

.fig
operation: publishack
.!fig

.section Peer-to-Peer

Mensajes con formato binarios representados en little-endian sobre protocolo
TCP.

Todos los mensajes comienzan con un código de operación.

.subsection Mensajes de cliente

.subsubsection File request

Consulta la disponibilidad de un archivo para ser descargado.

.itemize
.item Código: 0x01
.item Campos:
.item - Hash[20]: firma hash del fichero.
.item Respuestas: accepted o file not found error

.fig
0        1        3        4        5        byte
+--------+
| opcode |
+-------------------------------------------+
| hash                                      |
|                                           |
|                                           |
|                                           |
+-------------------------------------------+
.!fig

.subsubsection Chunk request

Solicita al servidor el envío de un archivo.

.itemize
.item Código: 0x02
.item Campos:
.item - Offset[8]: byte de inicio del chunk.
.item - Size[4]: tamaño del chunk.
.item Respuestas: chunk o bad chunk request error

.fig
0        1       2       3       4       5       6       7       8         byte
+--------+----------------------------------------------------------------+
| opcode | offset                                                         |
+--------+----------------------+-----------------------------------------+
| size                          |
+-------------------------------+
.!fig


.subsubsection Stop download

Termina la descarga actual de un fichero.

.itemize
.item Código: 0x03
.item Campos: ninguno.
.item Respuestas: ninguna.

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsubsection Upload request

Solicita a un servidor la subida de un archivo.

.itemize
.item Código: 0x04
.item Campos: 
.item - hash[20]: firma hash del fichero.
.item - Respuestas: 'accepted' o 'File already exists'.

.fig
0        1        2        3        4        byte
+--------+
| opcode |
+-------------------------------------------+
| hash                                      |
|                                           |
|                                           |
|                                           |
+-------------------------------------------+
.!fig

.subsubsection File name to save

Da al servidor un nombre con el que guardar un archivo.

Este mensaje es enviado solo si el mensaje upload request fue aceptado previamente.

.itemize
.item Código: 0x05
.item Campos: 
.item - length[4]: lenght of name in bytes
.item - name[length]
.item Respuestas: 'accepted' o 'file not found error'

.fig
0        1        2        3        4        byte
+--------+----------------------------------+
| opcode | length                           | 
+-------------------------------------------+
| name                                      |
|                                           |
|                                           |
|                                           |
+-------------------------------------------+
.!fig

.pagebreak

.subsection Mensajes de servidor

.subsubsection Accepted

Informa de la disponibilidad de un fichero para ser descargado vía chunk requests.

.itemize
.item Código: 0x11
.item Campos: ninguno.
.item Respuesta a: file request

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsubsection Bad file request error

Fichero no disponible o no encontrado.

.itemize
.item Código: 0x12
.item Campos: ninguno.
.item Respuesta a: file request

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.subsubsection Chunk

Chunk de datos del fichero.

.itemize
.item Código: 0x13
.item Campos:
.item - size[4]: tamaño del chunk.
.item - data[size]: datos.
.item Respuesta a: chunk request

.fig
0        1       2       3       4       byte
+--------+------------------------------+
| opcode | size                         |
+--------+------------------------------+
| data ...
|
.!fig

.subsubsection Bad chunk request error

Fichero no disponible o no encontrado.

.itemize
.item Código: 0x14
.item Campos: ninguno.
.item Respuesta a: chunk request

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.pagebreak

.subsubsection File already exists

El fichero ya existe en este peer.

.itemize
.item Código: 0x15
.item Campos: ninguno
.item Respuesta a: 'upload request'

.fig
0               
+--------+
| opcode |
+--------+
.!fig

.section Autómatas de Protocolo

Véase directorio de imagenes.

.chapter Mejoras

.section Quit

Se mejoró el comportamiento del comando quit para que al ejecutarse se actualice en el directorio la información relativa al peer que hace el quit: se da de baja a dicho peer junto con los ficheros que exclusivamente este compartía.

Para hacerlo se implentaron dos estructuras de datos con la clase HashMap. Un atributo llamado 'database' que guarda las relaciones hash-fichero de los documentos publicados, y otro llamado 'peers' para las relaciones peer_socket-ficheros.

También se diseñó una clase llamada ExternFile descendiente de FileInfo cuya principal característica es que tiene un atributo para guardar las direcciones de los peers que comparten un fichero. Esta clase es la que participa en el mapa database.

Cuando un peer se da de baja, se busca en el mapa peers los documentos que este comparte y se obtienen las firmas hash. Con los hash se buscan los ficheros en database para actualizar la lista de peers que los comparten. Si un fichero solo es compartido por ese peer, se borra de database. Luego se elimina el peer del mapa peers.

.section Serve con puerto efimero

Originalmente el comando serve montaba un servidor escuchando en el puerto 10000. Con esta mejora el servidor queda escuchando en un puerto aleatorio que se registra en el directorio.

.section Filelist

La version basica de filelist solo muestra información basica de los ficheros registrados en el servidor (nombre, firma hash, tamaño). Con está ampliación también se muestra el listado de peers (direciones) que disponen de dichos ficheros.

Esto se puede gracias a que con la información de filelist se crean objetos ExternFile, una clase que permite guardar los servidores que comaparten un fichero.

.section Upload

Comando que permite a un servidor enviar un documento a otro servidor siempre y cuando este último no lo tenga ya. Para poder ejecutar este comando el peer debe darse de alta como servidor en el directorio previamente.

Para su funcionamiento se modificó el método serveFilesToClient para que pueda tratar el comando upload.

.chapter Capturas de pantalla de Wireshark

Véase directorio de imagenes.

.chapter Conclusiones

La compartición de archivos peer-to-peer es un gran metodo para compartir archivos, es extremadamente eficiente y robusta gracias a su descentralización y división de contenido en piezas (chunks)
(siempre y cuando hayan peers) y permite que los operadores de los directorios se desmarquen en caso de que se compartan archivos cuyo contenido sea por lo que sea, legalmente gris.

Sin embargo, no todos los protocolos de compartición P2P son igual de buenos. En este caso se ha hecho lo que se ha podido. A continuación, una breve opinión sobre lo que se podría mejorar.

.pagebreak

.section Valoracion personal

.subsection Por qué el proyecto base de Nanofiles es perjudicial: Un analisis

.subsubsection Elección del lenguaje

Java era un lenguaje ampliamente usado para escribir software nuevo... hace 15 años. Ahora se considera como mala opción, como deuda tecnica (por razones fuera del alcance de este documento) no se escribe nuevo software en el, solo se mantiene el antiguo porque es mas barato que reescribirlo.

Especificamente, Java es una opción terrible para este caso porque es un obstaculo para el objetivo del proyecto: aprender a escribir aplicaciones con sockets.

Java, siendo OOP puro, está sujeto a limitaciones que le impiden representar fielmente como funcionan las cosas. La API tiene una serie de clases para representar datagramas UDP por ejemplo: los datagramas existen, pero la clase DatagramPacket es algo muy abstracto que en ningún momento representa el paquete real, sino juntar datos en una unidad porque sí. Java no sabe lo que es un datagrama realmente.

Que queremos enviar un cacho de datos a varias direcciones: tenemos que construir un DatagramPacket para cada vez, con los mismos datos, pero con una dirección de destino distinta. Java está lleno de estas construcciones, copias copias y copias y destrucciones completamente innecesarias.

Cada día nos alejamos mas de C: La API de sockets de Java está demasiado alejada de la verdad: la API de sockets POSIX. Esa que todos los sitemas operativos reales implementan de una forma u otra desde BSD 4.2 (incluso Windows), que es lo que la JVM realmente usa por debajo para hablar con la red.

Esta API POSIX, tenemos unos datos, y los enviamos a una direccion, en una sola llamada, y sin ningún tipo de construcción o copia de nada. Es el kernel el que coje el búfer de memoria, construye el paquete UDP, lo encapsula en un frame Ethernet y se lo pasa al driver de la tarjeta de red (generalmente).

.itemize
.item Java no esta diseñado para trabajar con datos binarios facilmente, teniendo que serializar y deserializar todo, y ni si quiera soporta tipos enteros sin signo explicitamente.
.item Aparentemente no hay forma de coger un trozo de un archivo y mandarlo por un socket sin copiar el bufer, lenguaje inutilizable, ¿Como se permite esto en 2025?
.item Java es muy inflexible en cuanto a operaciones no bloqueantes. POSIX tiene la syscall poll() para monitorear una lista de sockets en un solo thread, y Java tiene algo parecido pero crucialmente. En C puedes responder con llamadas bloqueantes sabiendo que no se van a bloquear, mientras que en Java solo puedes usar cosas no bloqueantes sobre un canal con select, lo cual es pedantico y molesto.

.pagebreak

.subsection Problemas con el protocolo pedido

En respuesta a la descripción dada de los mensajes: Argumento detrás del protocolo aquí definido

.subsubsection Directorio

El protocolo que se describe es mas innecesariamente complicado de lo que podría ser: Es mucho mas eficiente enviar toda la información del directorio en un solo mensaje, incluyendo nombres, hashes, tamaños y peers de cada archivo, ya que en la interfaz de usuario del programa, se va a mostrar todos los ficheros disponibles y se podrán bajar cualquiera de ellos.

Y como el cliente ya tiene toda la información de un golpe, no necesita enviar ningún mensaje para pedir la lista de peers; pero si aún asi quisieramos hacerlo, no debería hacerse en el protocolo mediante una subcadena de longitud variable. Esto da lugar a errores y ambigüedades que se pueden evitar usando directamente el hash SHA1 en binario que ya conoce el cliente para referirse a un archivo concreto y especifico.

Aparte, opino que al ser un protocolo textual, sería infinitamente mas estandar, sencillo y escalable si este protocolo fuese JSON sobre HTTP, haciendo del directorio una API REST, parecido a bittorrent.

.subsubsection Transferencia de ficheros

Antes de empezar, remarcar que todo el punto de partir los archivos en piezas (chunks) es de poder obtener las piezas de distintos peers, idealmente de forma randomizada y uniforme, de manera que si un peer no tiene una pieza o falla al enviarla, no cueste demasiado pedirsela a otro peer.

Con ese fin, el cliente debe tener el control granular de poder pedir piezas concretas. En este protocolo se admiten pedir pieas de distintos tamaños ya que se representa el offset y el tamaño, pero como mejora, la sesión debería fijar un tamaño, y en las comunicaciones subsecuentes indicarse indices de piezas.

En el establecimiento de la sesión, al igual que al obtener los peers del directorio, es propenso a errores indicar una subcadena, otra vez. Mejor enviar el hash exacto en binario, y además asi se evita tener que tener un campo de longitud, ya que el mensaje sería de longitud fija (la longitud se infiere del tipo de mensaje). Solo habría dos respuestas posibles, hash encontrado o no, no hay lugar a la ambigüedad en este protocolo.

Se menciona un mensaje del cliente con el hash del archivo, y que sección del archivo descargar mediante dos offsets. Teniendo en cuenta lo anterior, es redundante, y lo segundo se ha exmplicado anteriormente.

Se podría llegar a pensar que el cliente al tener que pedir cada chunk individualmente daría lugar a un overhead de protocolo, pero esto se mitiga muy eficazmente enviando un numero de requests de piezas en el aire (en la ventana de recepción, o en el stack de aplicación del servidor), o lo que se llama pipelining de requests, de forma que el servidor las sirva lo mas rapido que pueda.

También se habla de que los chunks sean de 1KiB de tamaño. Esto es absurdamente pequeño ya que simplemente el header representaría aproximadamente el 1% del trafico de chunks, nada eficiente para archivos grandes o pequeños. En bittorrent se recomiendan mensajes de 16KiB para piezas de 2MiB. Aquí se usan chunks de 2MiB directamente porque no hay concepto de bloque separado de pieza. Así el kernel trabaja más (eficiencia).

Por último, no conseguimos entender la utilidad de obtener el hash del archivo pedido por el cliente al servidor tras establecer la sesión, ya que en el propio establecmimento uno de los parametros es el mismo hash. Redundante.

Como mejora al protocolo se podrían introducir conceptos de control de flujo de bittorrent, como condición de choking y interest.

.subsection Problemas con el código dado

.subsubsection General

.align left
.itemize
.item Legibilidad horrible
.item Nombres confusos, ambiguos
.item Inconsistencias de patrones
.item Innecesariamente complicado
.item Verbosidad (mas culpa de Java supongo)
.item Exceso de comentarios y además confusos
.item Capa sobre capa sobre capa de abstracciones: paso de datos entre clases que no hacen nada innecesariamente
.item Enumeraciones, arrays, estructuras innecesarias, como los comandos.
.align justify

.subsubsection Especifico

Nos dan el proyecto para Eclipse, usando el build system de eclipse. Con lo cual nos obligan a usar Eclipse. Los IDEs son un obstaculo para el aprendizaje. Tienen una cantidad de ruido visual increibles, son enormemente complicados de usar y suelen tener bugs y molestias. La alternativa es "convertirlo a gradle" y usar gradle que es otro build system terrible y innecesariamente complejo.

.itemize Ejemplo de TODO ambiguo: ¿En cual se crea el hilo?
.item NFControllerP2P: "Arrancar servidor en segundo plano creando un nuevo hilo"
.item NFServer: "Añadir métodos a esta clase para: 1) Arrancar el servidor en un hilo nuevo que se ejecutará en segundo plano". La verdadera respuesta es que hay que fijarse que NFServer implementa Runnable, con lo cual es esta clase la que hay que pasar a un Thread, y run() el metodo que ejecuta el Thread, siendo este declarado efectivamente en NFControllerP2P.

.itemize Ejemplo de TODO confuso e incongruente:
.item NFServer implements Runnable: "Añadir métodos a esta clase para: [...] 2) Detener el servidor (stopserver)" Como vas a parar el servidor dentro del mismo thread, si el thread está bloqueado en accept()? Si no se usan sockets no bloqueantes (no los hemos visto) la unica forma de detener el thread es terminandolo a la fuerza desde el thread Main.

.itemize Ejemplo de TODO directamente incorrecto:
.item NFServer.serveFilesToClient: "Los métodos lookupHashSubstring y lookupFilenameSubstring de la clase FileInfo" lookupHashSubstring no existe en ningún sitio. Además, estas utilidades deberían estar en la base de datos FileDatabase, literalmente son queries a la base de datos. Sin embargo, lookupFilePath sí que está en la FileDatabase, ¿por qué? Es como si se hubieran puesto los metodos de forma aparentemente aleatoria por el codigo. Nota: esta función tampoco sirve a un proposito porque en el servidor se necesita el resto de campos del objeto FileInfo, no solo su path. Debería de haber un solo metodo para buscar en la db por hash o por nombre y devolver el FileInfo, solo que por alguna razón divinamente desconocida, a FileInfo le falta el getter del path. (Nota: solo tiene sentido guardar el path entero en FileInfo, ya que el nombre es parte del path y por tanto redundante)

.align left
.itemize FileDatabase es AdHoc, solo sirve como base de datos del cliente:
.item escanea un directorio
.item no puede guardar peers para usarse en NFDirectoryServer
.align justify

DirMessage intenta representar todos los tipos de mensajes, haciendo la implementación terrible: encima de que estamos en un lenguaje OOP esto deberia ser resuelto por herencia para cada tipo de mensaje.

NFDirectoryServer termina inmediatamente al recibir un mensaje mal formado, esto es una vulnerabilidad de Denial of Service.

NanoFiles (cliente) termina inmediatamente en cuanto un comando falla. Cuando haces un ping y el directorio no responde, termina, en vez de dejarte volver a intentar.

NFController.processCommand()[COM_DOWNLOAD]: A dos metodos aislados se le pasa la misma información inutil (una substring del nombre del archivo). Sin modificar estos, los dos metodos necesitan el hash del archivo -> tendrian que hacer la misma request al directorio para ver a que hash se corresponde (información util) para poder preguntar por A. los servidores y B. a los peers, los chunks del archivo. Diseño fundamentalmente defectuoso. Lo primero que se debería hacer es obtener la información util, el hash, que es con lo que se debe trabajar.


